\subsection{Assembler}
\label{sec:assembler}
Since we decided to not support some of the RV32I instructions and we were not going to compile high level code, we decided to write our own custom assembler. So we came up with \textit{com.py}. It is not a compiler, despite the name, nor a full RV32I assembler, and doesn't claim to be. The main reason for its name is the fact that it ends in \textit{py}, and there you are the wordplay with its extension. Still, an assembler could be seen as a simple compiler for a low level language. 

\subsubsection{Features}
Here is a little perspective on the main feature of \textit{com.py}.
\begin{itemize}
   \item Most of the instructions from RV32I are supported, excluding:
   \begin{itemize}
      \item Environmental CALL (\texttt{ecall}) and BREAK (\texttt{ebreak}) instructions
      \item Synch thread (\texttt{fence}) and synch instruction \& data (\texttt{fence.i}) instructions
      \item Status register manipulation instructions (\texttt{csr*})
   \end{itemize}
   \item Most pseudo-instruction are supported, excluded the ones that have to be translated to more than one instruction and those related to the unsupported base instructions.
   \item All the instructions and pseudo-instructions are processed and assembled making heavy use of python dictionaries. This greatly simplifies the code and most important keeps the assembler modular. Adding a new instruction is normally as easy as introducing a new \texttt{[key]: [value]} couple to the dictionaries. 
   \item The output machine code can be provided both as ASCII binary file or ASCII hexadecimal file, so that they can be employed as source files for simulation.
   \item If requested, assembler can set-up a System Verilog file containing the simulation parameters, linking it to the assembled machine code. Then, a simulation script is launched in Modelsim. 
   \item Registers can be addressed by their architectural names (\texttt{x[n]}) or by their ABI (Application Binary Interface) names (e.g. \texttt{ra} or \texttt{sp}). 
   \item The offset field can be passed both as a standalone parameter (e.g \texttt{sw rs1, rs2, imm}) or as parenthesis prefix (e.g \texttt{sw rs2, imm(rs1)}). 
   \item Comments are introduced by character \texttt{\#} and are ignored.
   \item Very basic syntax error detection is provided.
   \item This is not meant to be a usage guide, so run \texttt{./com.py -h} for more help.
\end{itemize}

\subsubsection{How it works}
Figure \ref{fig:compy} shows a qualitative flow chart of the assembler. After opening the input file, the script reads one line at a time and remove comments. Pseudo-instructions are then converted to base ones and processed, while the canonical format is retrieved:
\begin{center}
   \texttt{instr\_name param1, param2, [param3]} 
\end{center}
Then, all the instructions are processed the same way. The fields of the machine code that depends only on the type of instruction and the instruction name are processed first. After, the parameters like registers and immediate/offset fields are encoded based on the instruction type. Eventually, all the fields are printed on screen, joined together and appended to a ASCII binary output file with extension \texttt{.mc}. Since the assembler doesn't keep a copy of the entire code but processes one instruction at a time, memory usage is kept under control even when dealing with long pieces of assembly code. 

As soon as an error is encountered processing one line (i.e. one instruction) the user is warned by a message on screen and the assembler exits with a specific error code. This makes it possible to use this script inside other bash or python scripts. Errors are handled by means of python exception handling \texttt{try:... except:...} construct, that interprets these exceptions based on the assembling context instead of throwing generic python interpreter errors to the user. 

Here is an example of the output of the assembler when processing a piece of RISC-V assembly code that computes the Fibonacci sequence:

\begingroup
    \fontsize{9pt}{12pt}\selectfont
    \begin{verbatim}  
RV-MAGIC/common/src$ ./com.py ../../main/tb/assembly/fibo.asm y n

> =================================================================
>              2019-03-20 19:42:31 - Welcome to com.py
> =================================================================


> Assembling "../../main/tb/assembly/fibo.asm"...
>       1)    li x5, 7              =>   I-type: 000000000111  00000 000 00101 0010011
>       2)    li x6, 2              =>   I-type: 000000000010  00000 000 00110 0010011
>       3)    jal ra, 8             =>   J-type: 00000000100000000000    00001 1101111
>       4)    j 72                  =>   J-type: 00000100100000000000    00000 1101111
>       5)    bge x5, x6, 12        =>   B-type: 0000000 00110 00101 101 01100 1100011
>       6)    addi x7, x5, 0        =>   I-type: 000000000000  00101 000 00111 0010011
>       7)    jalr x0, 0(ra)        =>   I-type: 000000000000  00001 000 00000 1100111
>       8)    addi sp, sp, -12      =>   I-type: 111111110100  00010 000 00010 0010011
>       9)    sw x1, 0(sp)          =>   S-type: 0000000 00001 00010 010 00000 0100011
>       10)   sw x5, 4(sp)          =>   S-type: 0000000 00101 00010 010 00100 0100011
>       11)   addi x5, x5, -1       =>   I-type: 111111111111  00101 000 00101 0010011
>       12)   jal ra, -28           =>   J-type: 11111110010111111111    00001 1101111
>       13)   sw x7, 8(sp)          =>   S-type: 0000000 00111 00010 010 01000 0100011
>       14)   lw x5, 4(sp)          =>   I-type: 000000000100  00010 010 00101 0000011
>       15)   addi x5, x5, -2       =>   I-type: 111111111110  00101 000 00101 0010011
>       16)   jal ra, -44           =>   J-type: 11111101010111111111    00001 1101111
>       17)   lw x13, 8(sp)         =>   I-type: 000000001000  00010 010 01101 0000011
>       18)   add x7, x13, x7       =>   R-type: 0000000 00111 01101 000 00111 0110011
>       19)   lw ra, 0(sp)          =>   I-type: 000000000000  00010 010 00001 0000011
>       20)   addi sp, sp, 12       =>   I-type: 000000001100  00010 000 00010 0010011
>       21)   jalr x0, 0(ra)        =>   I-type: 000000000000  00001 000 00000 1100111

> BIN file successfully created:
      RV-MAGIC/main/tb/bin_mc/fibo.mc

> HEX file successfully created:
      RV-MAGIC/main/tb/hex_mc/fibo.riscv
    \end{verbatim}  
\endgroup

Eventually, if no error was encountered, a hexadecimal file with extension \texttt{.riscv} is generated starting from the binary one. If requested, the script proceeds linking the assembled code in a System Verilog test-bench configutation file and launches the simulation in Modelsim, running a \texttt{.tcl} script with the necessary commands to compile and simulate the entire design. Since this configuration file can also be used for other purposes, \textit{com.py} keeps a copy of the old version and restores it when Modelsim is quit. 

\begin{figure}[hbtp]
   \centering
   \includegraphics[scale=.6]{../common/ref/schematic/compy.pdf}
   \caption{\textit{com.py} flow chart}
   \label{fig:compy}
\end{figure}